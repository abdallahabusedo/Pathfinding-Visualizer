{"version":3,"sources":["assets/images/Logo.png","Components/Node/Node.jsx","Components/welcome/welcome.jsx","Components/welcome/Footer.jsx","Components/BFS Algorithm/BFS.js","Components/pathFindingVisualizer/pathFindingVisualizer.jsx","App.js","index.js"],"names":["module","exports","Node","this","props","col","isFinish","isStart","isWall","row","onMouseDown","onMouseEnter","onMouseUp","extraClassName","id","className","Component","welcome","src","Logo","alt","Fotter","style","color","href","updateUnvisitedNeighbors","node","grid","unVisitedNeighbors","neighbors","push","length","filter","neighbor","isVisited","getUnVisitedNeighbors","distance","previousNode","Dijkstra","startNode","finishNode","visitedNodesInOrder","unvisitedNodes","nodes","getAllNodes","sort","nodeA","nodeB","closestNode","shift","Infinity","createNode","getNewGridWithWallToggled","newGrid","slice","newNode","pathFindingVisualizer","componentDidMount","Grid","currentRow","getInitialGrid","setState","handleMouseDown","state","mouseIsPressed","handleMouseEnter","handelMouseUp","animateAlgorithm","nodesInShortestPathOrder","i","setTimeout","animateShortestPath","document","getElementById","currentNode","unshift","getNodesInShortestPathOrder","onClick","visualizeAlgorithm","name","value","map","rowIdx","key","nodeIdx","App","ReactDOM","render","StrictMode"],"mappings":"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","file":"static/js/main.c20a921b.chunk.js","sourcesContent":["module.exports = __webpack_public_path__ + \"static/media/Logo.3be884cc.png\";","import React, { Component } from \"react\";\nimport \"./Node.css\";\nexport default class Node extends Component {\n  render() {\n    const {\n      col,\n      isFinish,\n      isStart,\n      isWall,\n      row,\n      onMouseDown,\n      onMouseEnter,\n      onMouseUp,\n    } = this.props;\n    const extraClassName = isFinish\n      ? \"node-finish\"\n      : isStart\n      ? \"node-start\"\n      : isWall\n      ? \"node-wall\"\n      : \"\";\n\n    return (\n      <div\n        id={`node-${row}-${col}`}\n        className={`node ${extraClassName}`}\n        onMouseDown={() => onMouseDown(row, col)}\n        onMouseEnter={() => onMouseEnter(row, col)}\n        onMouseUp={() => onMouseUp()}\n      ></div>\n    );\n  }\n}\n","import React, { Component } from \"react\";\nimport \"./welcome.css\";\nimport Logo from \"./../../assets/images/Logo.png\";\nclass welcome extends Component {\n  render() {\n    return (\n      <div>\n        <div className=\"welcome__Logo\">\n          <img src={Logo} className=\"welcome__Logo\" alt=\"logo\" />\n        </div>\n      </div>\n    );\n  }\n}\n\nexport default welcome;\n","import React, { Component } from \"react\";\nimport \"./welcome.css\";\nexport default class Fotter extends Component {\n  render() {\n    return (\n      <div>\n        <h5 className=\"welcome__MyName\">\n          MADE WITH <span style={{ color: \"red\" }}>LOVE</span> BY{\" \"}\n          <ins>ABDALLAH ABU SEDO</ins>\n          <a href=\"https://github.com/abdallahabusedo/Pathfinding-Visualizer\">\n            <i className=\"fab fa-github Footer__Icon\"></i>\n          </a>\n        </h5>\n      </div>\n    );\n  }\n}\n","/**\n *\n * @param {*} grid\n * @function getAllNodes\n * @description store all nodes in the Nodes array\n */\nfunction getAllNodes(grid) {\n  const nodes = [];\n  for (const row of grid) {\n    for (const node of row) {\n      nodes.push(node);\n    }\n  }\n  return nodes;\n}\n/**\n *\n * @param {*} unVisitedNode\n * @function sortNodesByDistance\n * @description sort Nodes By Distance\n */\nfunction sortNodesByDistance(unVisitedNode) {\n  unVisitedNode.sort((nodeA, nodeB) => nodeA.distance - nodeB.distance);\n}\n\n/**\n *\n * @param {*} node\n * @param {*} grid\n * @function updateUnvisitedNeighbors\n * @description update Unvisited Neighbors\n */\nfunction updateUnvisitedNeighbors(node, grid) {\n  const unVisitedNeighbors = getUnVisitedNeighbors(node, grid);\n  for (const neighbor of unVisitedNeighbors) {\n    neighbor.distance = node.distance + 1;\n    neighbor.previousNode = node;\n  }\n}\n/**\n *\n * @param {*} node\n * @param {*} grid\n * @function getUnVisitedNeighbors\n * @description get UnVisited Neighbors\n */\n\nfunction getUnVisitedNeighbors(node, grid) {\n  const neighbors = [];\n  const { col, row } = node;\n  if (row > 0) neighbors.push(grid[row - 1][col]);\n  if (row < grid.length - 1) neighbors.push(grid[row + 1][col]);\n  if (col > 0) neighbors.push(grid[row][col - 1]);\n  if (col < grid.length - 1) neighbors.push(grid[row][col + 1]);\n  return neighbors.filter((neighbor) => !neighbor.isVisited);\n}\n/**\n *\n * @param {*} finishNode\n * @function getNodesInShortestPathOrder\n * @description get Nodes In Shortest Path Order\n */\nexport function getNodesInShortestPathOrder(finishNode) {\n  const nodesInShortestPathOrder = [];\n  let currentNode = finishNode;\n  while (currentNode !== null) {\n    nodesInShortestPathOrder.unshift(currentNode);\n    currentNode = currentNode.previousNode;\n  }\n  return nodesInShortestPathOrder;\n}\n/**\n *\n * @param {*} grid\n * @param {*} startNode\n * @param {*} finishNode\n * @function\n */\nexport function Dijkstra(grid, startNode, finishNode) {\n  const visitedNodesInOrder = [];\n  startNode.distance = 0;\n  const unvisitedNodes = getAllNodes(grid);\n  while (!!unvisitedNodes.length) {\n    sortNodesByDistance(unvisitedNodes);\n    const closestNode = unvisitedNodes.shift();\n    // If we encounter a wall, we skip it.\n    if (closestNode.isWall) continue;\n    // If the closest node is at a distance of infinity,\n    // we must be trapped and should therefore stop.\n    if (closestNode.distance === Infinity) return visitedNodesInOrder;\n    closestNode.isVisited = true;\n    visitedNodesInOrder.push(closestNode);\n    if (closestNode === finishNode) return visitedNodesInOrder;\n    updateUnvisitedNeighbors(closestNode, grid);\n  }\n}\n// export class Queue {\n//   constructor(ele) {\n//     if (ele instanceof Array) {\n//       this.items = ele;\n//     } else {\n//       this.items = [];\n//     }\n//     this.length = this.items.length;\n//   }\n\n//   enqueue(ele) {\n//     this.length += 1;\n//     return this.items.push(ele);\n//   }\n\n//   dequeue() {\n//     if (this.length > 0) {\n//       this.length -= 1;\n//     }\n//     return this.items.shift();\n//   }\n// }\n\n// export function BFS(grid, startNode, finishNode) {\n//   let queue = new Queue();\n//   queue.enqueue(startNode);\n//   cameFrom[startNode] = null;\n//   while (true) {\n//     current = queue.dequeue();\n//     current.visited = true;\n//     path.push(current.id);\n//     if (current.id === finishNode) {\n//       break;\n//     }\n//     current.adj.forEach((id) => {\n//       if (cameFrom[id]) {\n//       } else {\n//         cameFrom[id] = current.id;\n//       }\n\n//       let node = getNodeById(graph, id);\n//       if (!node.visited) {\n//         node.visited = true;\n//         queue.enqueue(node);\n//       }\n//     });\n//   }\n// }\n","import React, { Component } from \"react\";\nimport Node from \"./../Node/Node\";\nimport \"./pathFindingVisualizer.css\";\nimport Welcome from \"./../welcome/welcome\";\nimport Footer from \"./../welcome/Footer\";\nimport {\n  Dijkstra,\n  getNodesInShortestPathOrder,\n} from \"./../BFS Algorithm/BFS.js\";\nconst START_NODE_ROW = 0;\nconst START_NODE_COL = 49;\nconst FINISH_NODE_ROW = 10;\nconst FINISH_NODE_COL = 10;\n\n/**\n * @function\n * @description this function create a new Grid by start in the first row then create an array that pushes node in every col then pushes the row in the grid array\n * @returns {array} Grid\n */\nconst getInitialGrid = () => {\n  const Grid = [];\n  for (let row = 0; row < 20; row++) {\n    const currentRow = [];\n    for (let col = 0; col < 50; col++) {\n      currentRow.push(createNode(col, row));\n    }\n    Grid.push(currentRow);\n  }\n  return Grid;\n};\n/**\n *\n * @param {*} col\n * @param {*} row\n * @function createNode\n * @description returns node proprieties\n */\nconst createNode = (col, row) => {\n  return {\n    col,\n    row,\n    isStart: row === START_NODE_ROW && col === START_NODE_COL,\n    isFinish: row === FINISH_NODE_ROW && col === FINISH_NODE_COL,\n    distance: Infinity,\n    isVisited: false,\n    isWall: false,\n    previousNode: null,\n  };\n};\n\n/**\n *\n * @param {*} grid\n * @param {*} row\n * @param {*} col\n * @function getNewGridWithWallToggled\n * @description remove the walls from the grid\n */\nconst getNewGridWithWallToggled = (grid, row, col) => {\n  const newGrid = grid.slice();\n  const node = newGrid[row][col];\n  const newNode = {\n    ...node,\n    isWall: !node.isWall,\n  };\n  newGrid[row][col] = newNode;\n  return newGrid;\n};\n\nexport default class pathFindingVisualizer extends Component {\n  constructor(props) {\n    super(props);\n    this.state = {\n      Grid: [],\n      mouseIsPressed: false,\n    };\n  }\n\n  /**\n   * @function componentDidMount\n   * @description Create new grid and set it in the state\n   */\n  componentDidMount = () => {\n    const Grid = getInitialGrid();\n    this.setState({ Grid });\n  };\n  handleMouseDown = (row, col) => {\n    const newGrid = getNewGridWithWallToggled(this.state.Grid, row, col);\n    this.setState({ Grid: newGrid, mouseIsPressed: true });\n  };\n  handleMouseEnter = (row, col) => {\n    if (!this.state.mouseIsPressed) return;\n    const newGrid = getNewGridWithWallToggled(this.state.Grid, row, col);\n    this.setState({ Grid: newGrid });\n  };\n  handelMouseUp = () => {\n    this.setState({ mouseIsPressed: false });\n  };\n  animateAlgorithm = (visitedNodesInOrder, nodesInShortestPathOrder) => {\n    for (let i = 0; i <= visitedNodesInOrder.length; i++) {\n      if (i === visitedNodesInOrder.length) {\n        setTimeout(() => {\n          this.animateShortestPath(nodesInShortestPathOrder);\n        }, 5 * i);\n        return;\n      }\n      setTimeout(() => {\n        const node = visitedNodesInOrder[i];\n        document.getElementById(`node-${node.row}-${node.col}`).className =\n          \"node node-visited\";\n      }, 5 * i);\n    }\n  };\n\n  visualizeAlgorithm() {\n    const { Grid } = this.state;\n    const startNode = Grid[START_NODE_ROW][START_NODE_COL];\n    const finishNode = Grid[FINISH_NODE_ROW][FINISH_NODE_COL];\n    const visitedNodesInOrder = Dijkstra(Grid, startNode, finishNode);\n    const nodesInShortestPathOrder = getNodesInShortestPathOrder(finishNode);\n    this.animateAlgorithm(visitedNodesInOrder, nodesInShortestPathOrder);\n  }\n  animateShortestPath(nodesInShortestPathOrder) {\n    for (let i = 0; i < nodesInShortestPathOrder.length; i++) {\n      setTimeout(() => {\n        const node = nodesInShortestPathOrder[i];\n        document.getElementById(`node-${node.row}-${node.col}`).className =\n          \"node node-shortest-path\";\n      }, 50 * i);\n    }\n  }\n  render() {\n    const { Grid, mouseIsPressed } = this.state;\n    return (\n      <>\n        <div>\n          <Welcome />\n          <button\n            className=\"PathFinding__BFSButton\"\n            onClick={() => this.visualizeAlgorithm()}\n          >\n            Visualize BFS Algorithm\n          </button>\n          <select name=\"Algorithm\" className=\"Select\">\n            <option value=\"Dijkstra\" className=\"Select__option\">\n              Dijkstra\n            </option>\n            <option value=\"Dijkstra\" className=\"Select__option\">\n              BFS\n            </option>\n          </select>\n        </div>\n        <div className=\"Grid\">\n          {Grid.map((row, rowIdx) => {\n            return (\n              <div key={rowIdx}>\n                {row.map((node, nodeIdx) => {\n                  const { row, col, isFinish, isStart, isWall } = node;\n                  return (\n                    <Node\n                      key={nodeIdx}\n                      col={col}\n                      row={row}\n                      isFinish={isFinish}\n                      isStart={isStart}\n                      isWall={isWall}\n                      mouseIsPressed={mouseIsPressed}\n                      onMouseDown={(row, col) => this.handleMouseDown(row, col)}\n                      onMouseEnter={(row, col) =>\n                        this.handleMouseEnter(row, col)\n                      }\n                      onMouseUp={() => this.handelMouseUp}\n                    />\n                  );\n                })}\n              </div>\n            );\n          })}\n        </div>\n        <Footer />\n      </>\n    );\n  }\n}\n","import React from \"react\";\nimport \"./App.css\";\nimport PathFindingVisualizer from \"./Components/pathFindingVisualizer/pathFindingVisualizer\";\nfunction App() {\n  return (\n    <div className=\"App\">\n      <PathFindingVisualizer />\n    </div>\n  );\n}\n\nexport default App;\n","import React from \"react\";\nimport ReactDOM from \"react-dom\";\nimport \"./index.css\";\nimport App from \"./App\";\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById(\"root\")\n);\n"],"sourceRoot":""}